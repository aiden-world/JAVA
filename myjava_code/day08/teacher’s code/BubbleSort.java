/*
数组的算法：
1、找最值
2、找最值下标
3、查找
（1）顺序查找
（2）二分查找
4、数组求和与平均值
5、数组复制
6、数组的反转
7、数组的排序
（1）冒泡排序
（2）直接选择排序
其他排序...
*/
class BubbleSort{
	public static void main(String[] args){
		int[] arr = {4,8,2,9,1};
		
		//最终实现排序  {1,2,4,8,9}
		/*
		冒泡排序：
			通过相邻元素的比较，不符合最终要求的顺序，就交换；
			（例如，要实现从小到大，如果arr[0] > arr[1]，就交换）
			这样经过了几轮之后最终实现排序。
			思路：从左边开始比较，把大的往右边移动
		第一轮：
			第一次：arr[0]与arr[1]比较，不需要交换
			第二次：arr[1]与arr[2]比较，交换    {4,2,8,9,1}
			第三次：arr[2]与arr[3]比较，不需要交换
			第四次：arr[3]与arr[4]比较，交换    {4,2,8,1,9}
					最大的沉到底，最右边，下一轮这个9不需要参与比较
		第二轮：
			第一次：arr[0]与arr[1]比较，交换    {2,4,8,1,9}
			第二次：arr[1]与arr[2]比较，不需要交换
			第三次：arr[2]与arr[3]比较，交换    {2,4,1,8,9}
					第二大的也沉到下面，下一轮这个8也不需要参与比较
		第三轮：
			第一次：arr[0]与arr[1]比较，不需要交换
			第二次：arr[1]与arr[2]比较，交换    {2,1,4,8,9}
				第三大的也沉到下面，下一轮这个4也不需要参与比较
		第四轮：
			第一次：arr[0]与arr[1]比较，交换    {1,2,4,8,9}
				第四大的也沉到下面，下一轮这个2也不需要参与比较
		排序结束
		*/
		for(int i=1; i<arr.length; i++){//外循环控制轮数  轮数 = arr.length-1轮
			//每一轮：比较很多次
			//每一轮，我这里都是从最左边开始比较arr[0]开始比较，一直往右依次两两比较
			//每一轮的总次数
			/*
			第一轮：i=1，总次数4次，j=0,1,2,3   j<arr.length-i
			第二轮：i=2，总次数3次，j=0,1,2
			第三轮：i=3，总次数2次，j=0,1
			第四轮：i=4，总次数1次，j=0
			*/
			for(int j=0; j<arr.length-i; j++){
				//每一次是相邻元素比较 						
				//arr[j]与arr[j+1]对的      arr[j-1]与arr[j]错误的
				// j的起始点是0，arr[j]不会越界，arr[j-1]会越界	
				// j的终点是arr.length-1-i, 
				//arr[j+1] ， i的最小值是1  arr[j+1]->arr.length-1-1不会越界
				//			  i的最大值是arr.length-1 --> arr.length-1-(arr.length-1)不会越界
				//arr[j]不会越界	
				if(arr[j] > arr[j+1]){//前面的元素 > 后面的元素， 就交换
					int temp = arr[j];
					arr[j] = arr[j+1];
					arr[j+1] = temp;
				}
			}
		}
		
		//显示最终排序结果
		for(int i=0; i<arr.length; i++){
			System.out.println(arr[i]);
		}
	}
}
